def get_node_maps(self) -> dict[str, dict[tuple[int, int], int]]:
        """Build and return a ConnectedTiling from absolute 2D coordinates.\n\n        - Recomputes offsets similarly to materialize(), without side effects.\n        - Raises ValueError if mixed code distances are detected.\n        """繝悶Ο繝・け/繝代う繝励ｒ邨ｶ蟇ｾ2D蠎ｧ讓吶↓蜀埼・鄂ｮ縺励※ ConnectedTiling 繧定ｿ斐☆縲・

        """
        # to_tiling 繧貞・縺ｫ蜻ｼ縺ｳ蜃ｺ縺励※蜀・Κ蠎ｧ讓吶ｒ遒ｺ螳溘↓謖√◆縺帙ｋ
        for b in self.blocks_.values():
            if getattr(b, "template", None) is not None:
                b.template.to_tiling()
        for p in self.pipes_.values():
            if getattr(p, "template", None) is not None:
                p.template.to_tiling()

        tilings_abs: list = []
        dset: set[int] = set()

        for pos, b in self.blocks_.items():
            if getattr(b, "template", None) is None:
                continue
            d_val = int(getattr(b, "d", getattr(b.template, "d", 0)))
            dset.add(d_val)
            dx, dy = block_offset_xy(d_val, pos, anchor=anchor)
            tilings_abs.append(offset_tiling(b.template, dx, dy))

        for (source, sink), p in self.pipes_.items():
            if getattr(p, "template", None) is None:
                continue
            d_val = int(getattr(p, "d", getattr(p.template, "d", 0)))
            dset.add(d_val)
            direction = get_direction(source, sink)
            dx, dy = pipe_offset_xy(d_val, source, sink, direction)
            tilings_abs.append(offset_tiling(p.template, dx, dy))

        if not tilings_abs:
            return ConnectedTiling([])
        if len(dset) > 1:
            raise ValueError("Mixed code distances (d) are not supported in a single layer")

        return ConnectedTiling(tilings_abs, check_collisions=True)

    

