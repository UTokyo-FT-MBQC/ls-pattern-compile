from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional

# import stim
# graphix_zx pieces
from graphix_zx.graphstate import GraphState, compose_in_parallel, compose_sequentially
from lspattern.accumulator import (
    FlowAccumulator,
    ParityAccumulator,
    ScheduleAccumulator,
)
from lspattern.blocks.base import RHGBlock, RHGBlockSkeleton
from lspattern.consts.consts import DIRECTIONS3D
from lspattern.mytype import (
    NodeIdLocal,
    PatchCoordGlobal3D,
    PhysCoordGlobal3D,
    PipeCoordGlobal3D,
)
from lspattern.pipes.base import RHGPipe, RHGPipeSkeleton
from lspattern.tiling.base import ConnectedTiling
from lspattern.utils import get_direction


class TemporalLayer:
    z: int
    qubit_count: int
    patches: list[PatchCoordGlobal3D]
    lines: list[PipeCoordGlobal3D]

    in_portset: dict[PatchCoordGlobal3D, list[NodeIdLocal]]
    out_portset: dict[PatchCoordGlobal3D, list[NodeIdLocal]]
    cout_portset: dict[PatchCoordGlobal3D, list[NodeIdLocal]]

    in_ports: list[NodeIdLocal]
    out_ports: list[NodeIdLocal]
    cout_ports: list[NodeIdLocal]

    schedule: ScheduleAccumulator
    flow: FlowAccumulator
    parity: ParityAccumulator

    local_graph: GraphState
    node2coord: dict[NodeIdLocal, PhysCoordGlobal3D]
    coord2node: dict[PhysCoordGlobal3D, NodeIdLocal]
    node2role: dict[NodeIdLocal, str]

    blocks_: dict[PatchCoordGlobal3D, RHGBlock]
    pipes_: dict[PipeCoordGlobal3D, RHGPipe]

    def __init__(self, z: int):
        self.z = z
        self.qubit_count = 0
        self.patches = []
        self.lines = []
        self.in_portset = {}
        self.out_portset = {}
        self.in_ports = []
        self.out_ports = []
        self.local_graph = None
        self.node2coord = {}
        self.coord2node = {}
        self.node2role = {}
        # accumulators
        self.schedule = ScheduleAccumulator()
        self.flow = FlowAccumulator()
        self.parity = ParityAccumulator()
        # ConnectedTiling/繝・Φ繝励Ξ繝ｼ繝磯｣邨千畑縺ｮ菫晄戟鬆伜沺
        self.blocks_ = {}
        self.pipes_ = {}
        self.tiling_node_maps = {}

    def materialize(self) -> None:
        # TODO: 2谺｡蜈・ｵ仙粋 -> populate縺ｮ讒区Φ
        assert all(block.template.trimmed for block in self.blocks_.values()), (
            "All blocks must have trimmed templates before instantiation."
        )
        assert all(pipe.template.trimmed for pipe in self.pipes_.values()), (
            "All pipes must have trimmed templates before instantiation."
        )
        for b in self.blocks_.values():
            b.template.to_tiling()
        for p in self.pipes_.values():
            p.template.to_tiling()

        # 2D 騾｣邨撰ｼ医ヱ繝・メ菴咲ｽｮ縺ｮ繧ｪ繝輔そ繝・ヨ縺ｯ譛ｪ閠・・・・        tilings = [
            *(b.template for b in self.blocks_.values() if getattr(b, "template", None)),
            *(p.template for p in self.pipes_.values() if getattr(p, "template", None)),
        ]
        if not tilings:
            self.tiling_node_maps = {}
            return

        ct = ConnectedTiling(tilings, check_collisions=True)
        # base/ConnectedTiling 縺ｮ node_maps 繧偵◎縺ｮ縺ｾ縺ｾ蜈ｬ髢・        self.tiling_node_maps = {
            "data": dict(ct.node_maps.get("data", {})),
            "x": dict(ct.node_maps.get("x", {})),
            "z": dict(ct.node_maps.get("z", {})),
        }

        return


